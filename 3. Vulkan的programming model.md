---
state: ongoing
---

# vulkan application都需要什么

要完成一个Vulkan API编写的应用，需要哪些东西呢？如下图所示。

![vulkan application需要的组件](images/3/1.png)

1. 首先，你需要一个**支持Vulkan的GPU**，否则无法运行应用；
2. 其次，你需要**Vulkan Driver**，这个不需要单独安装，一般和GPU一起绑定出厂；
3. 第三，为了写一个application，你需要**一套Vulkan SDK**；
4. 之后，写完的application需要运行**SPIR-V格式的shader**；
5. 最后，application得到的结果，需要显示在屏幕上，你需要**Windows System Integration**。

## 具体描述

### Driver

驱动是沟通application和GPU的中介，在application执行中，可以通过driver来查询GPU有多少可用的`PhysicalDevice`，每个`Device`中有多少个`Queue`，每个`Queue`具体什么功能。

Vulkan只是提供了一个统一的API，其具体的实现由各个硬件厂家完成，而这些厂家一般将驱动和对应的GPU绑定出厂。

### Application

由开发人员负责提供，用于执行图形渲染或者并发计算等任务。Vulkan programming model规范地说明了一个Vulkan application的一般化操作，下边会详述。

### Vulkan SDK

用于支持Vulkan application的一系列工具，类似Java中的JDK。

### SPIR-V

在GPU中通过可编程的shader来完成各种顶点计算、着色等操作，Vulkan中的shader是[SPIR-V格式](https://www.khronos.org/spir/)的——a precompiled binary format。这种形式的最大好处是在运行时不用编译了，提高了执行的效率，而且SDK中提供了compiler，可以将多种shader语言编写成SPIR-V的格式，如：[GLSL](https://www.khronos.org/opengl/wiki/Core_Language_(GLSL))、HLSL等。

### WSI

Vulkan application的结果不一定要展现在屏幕上，比如并行计算的结果，即便是对于图形渲染的结果也不是强制的，但是为了方便开发，显现在屏幕上还是有很多的需求。但是Vulkan官方的规范中没有明确提出与window system交互，而是通过extension来实现的。`Windows System Integration`就是来自Khronos的一系列extensions，统一了对于Linux、Windows和Android等屏幕呈现功能。

# Vulkan programming model

什么是编程模型，“模型”肯定是对一系列事务的共性的描述，那编程模型，可以理解为对于编程这件事的共性的描述。编程模型之前可以添加很多的定语，来描述“什么样的编程”的共性，例如：有事件驱动的编程模型等。

那么这里，就容易理解了——要说的是，通过vulkan API进行编程的共性的描述。也就是使用Vulkan API编程，不管是复杂还是简单，你一般都需要干哪些事情，具体应该怎么干。

Vulkan programming model整体结构如下：

![Vulkan programming model](images/3/2.png)

## Hardware Initialization
在application开始正常运行之前，首先需要初始化硬件。所谓初始化硬件，需要找到操作GPU的driver，这个操作是通过定位loader来实现的。

[Vulkan loader的文档](https://github.com/KhronosGroup/Vulkan-Loader)中说到：
> The ICD loader is a library that is placed between a Vulkan application and any number of Vulkan drivers, in order to support multiple drivers and the instance-level functionality that works across these drivers. Additionally, the loader manages inserting Vulkan layer libraries, such as validation layers, between an application and the drivers.

简单说：
- 一个代码组件，主要任务是在application启动时去查找GPU对应的driver；
- loader加载driver的方式在各个平台中是一致的。
    - 前面提到，在Vulkan中保证所有操作在所有平台都是一致的，不一致的地方通过extension的方式支持；

这个loader会还会完成哪些工作呢？在[loader中存在一个layered architecture](https://github.com/KhronosGroup/Vulkan-Loader/blob/master/docs/LoaderInterfaceArchitecture.md#overview)。如下图所示：

![Loader layered architecture](https://github.com/KhronosGroup/Vulkan-Loader/raw/master/docs/images/high_level_loader.png)

对于不希望在vulkan API中实现的功能，可以通过在这里加一个layer来实现，以实现与vulkan driver的解耦，当需要这些功能时就打开（开发阶段），不需要就关闭（发布阶段）。具体包括以下功能：
    - Error & Validation for debugging purpose
      在vulkan中，各种调试工作是通过validation layer实现的，不是vulkan core API的一部分，因此此时不需要找到vulkan driver。如[Validation layers](https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Validation_layers)所述。
    - Tracing vulkan API commands

一旦loader找到对应的driver并且成功建立链接，后续application需要逐步完成：
- create vulkan instance

  在vulkan中没有类似[OpenGL的global state](https://softwareengineering.stackexchange.com/questions/380832/opengl-and-global-state)，而是每个application都有自己的state，存储在`VkInstance`中，之后通过该对象初始化vulkan API，将application自身的信息传递出去。
- query physical devices for available queues
- query extensions and store them as function pointers

  如WSI (Window System Integration) extensions等。
- enable an injectable layer for error checking, debugging


## Windowing Presentation Surface

## Resource Setup


## Pipeline Setup


###

###


###

## Command Recordings

## Submission of Command


# 参考资料

1. https://vulkan-tutorial.com/Drawing_a_triangle/Graphics_pipeline_basics/Shader_modules
2. https://vulkan-tutorial.com/Drawing_a_triangle/Presentation/Window_surface
3. Learning Vulkan - Chapter 1 - Understanding the Vulkan application & Getting started with the Vulkan programming model
4. https://registry.khronos.org/vulkan/specs/1.3-extensions/html/chap4.html
